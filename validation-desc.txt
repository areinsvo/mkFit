This file is a compendium on how the validation runs within mkFit, which makes use of the TTreeValidation class and other supporting macros.  

Table of Contents

A. Overview of code
B. Overview of routine calls in mkFit
C. Explanation of validation routines
  I. Tracks and Extras Prep
  II. Track Association Routines
  III. TTree Filling
D. Definitions of efficiency, fake rate, and duplicate rate
E. Overview of scripts
F. Hit map/remapping logic
G. Extra info on ID and mask assignments

=====================
 A. Overview of code
=====================

TTreeValidation will only compile the necessary ROOT code with WITH_ROOT=yes enabled (either manually editting Makefile.config, or at the command line). Always do a make clean before compiling with ROOT, as the code is ifdef'ed. To hide the heavy-duty functions from the main code, TTreeValidation inherits from the virtual class "Validation", and overrides the common functions.  The TTreeValidation object is created once per number of events in flight. The Event object obtains a reference to the validation object (store as a data member "validation_"), so it is up to the Event object to reset some of the data members of the TTreeValidation object on every event.

Three types of validation exist within TTreeValidation:
[1.] "Building validation", enabled with Config::root_val, via the command line option: --root-val
[2.] "CMSSW external tracks building validation", enabled with Config::cmssw_val, via the command line options: --cmss-val --cmssw-seeds --ext-rec-tracks --geom CMS-2017
[3.] "Fit validation", enabled with Config::fit_val, via the command line option: --fit-val

We will ignore fit validation for the moment. The main idea behind the other two is that the validation routines are called outside of the standard timed sections, and as such, we do not care too much about performance, as long as it takes a reasonable amount of time to complete. Of course, the full wall clock time matters when running multiple events in flight, and because there is a lot of I/O as well as moves and stores that would hurt the performance with the validation enabled, these routines are ignored if the command line option "--silent" is enabled.

The building validation takes advantage of filling two trees per event per track, namely:
[1.] 
  - efftree (filled once per sim track) 
  - frtree (filled once per seed track)
[2.] 
  - cmsswefftree (filled once per cmssw external track)
  - cmsswfrtree (filled once per mkFit build track)

[1.] validation exists in the following combinations of geometry and seed source:
- ToyMC, with sim seeds or find-seeds
- CMSSW, with sim seeds or cmssw-seeds

Upon instantiation of the TTreeValidation object, the respective ROOT trees are defined and allocated on the heap, along with setting the addresses of all the branches. After the building is completed in mkFit, we have to have the tracks in their standard event containers, namely: seedTracks_, candidateTracks_, and fitTracks_. In the standard combinatorial or clone engine, we have to copy out the built tracks from event of combined candiates into candidateTracks_ via: builder.quality_store_tracks() in mkFit/buildtestMPlex.cc.  Since we do not yet have fitting after building, we just set the fitTracks_ equal to the candidateTracks_.  For ease, I will from now on refer to the candidateTracks_ as buildTracks_.

As a reminder, the sim tracks are stored in the Event.cc as simTracks_, while the CMSSW reco tracks are stored as extRecTracks_. Each track collection has an associated TrackExtra collection, which is stored as {trackname}Extra_ inside the Event object.  It is indexed the same as the collection it references, i.e. track[0] has an associated extra extra[0]. The TrackExtra object contains the mcTrackID, seedID, and cmsswTrackID each mkFit track is associated to. The validation also makes use of simHitsInfo_ (container for storing mcTrackID for each hit), layerHits_, and simTrackStates_ (used for pulls).  See Section B and C for explanations on how the track matching is performed and track information is saved.

Following each event, each of the track and extra objects are cleared. In addition, the association maps are cleared and reset. After the main loop over events expires, the ROOT file is written out with the TTrees saved via: val.saveTTrees() in mkFit.cc. The destructor for the validation then deletes the trees. The output is "valtree.root", appended by the thread number if using multiple events in flight.  From here, we then take advantage of the following files:

- runValidation.C // macro used for turning TTrees into efficiency/fake rate/duplicate rate plots
- PlotValidation.cpp/.hh // source code for doing calculations
- makeValidation.C // plots on a single canvas results for Best Hit (BH), Standard Combinatorial (STD), and Clone Engine (CE)

======================================
 B. Outline of routine calls in mkFit
======================================

The following routines are then called after the building (MkBuilder.cc, Event.cc, TTreeValidation.cc, Track.cc):

[1.] builder.root_val()
   : remap_seed_hits()
   : remap_cand_hits()
   : prep_recotracks()
     : prep_tracks(seedtracks,seedextras)
       : m_event->validation_.alignTracks(tracks,extras,false)
     : prep_tracks(buildtracks,buildextras)
       : m_event->validation_.alignTracks(tracks,extras,false)
     : prep_tracks(fittracks,fitextras)
       : m_event->validation_.alignTracks(tracks,extras,false)
   : if (cmssw-seeds) m_event->clean_cms_simtracks() // label which simtracks are not findable: already set if using sim seeds
   : m_event->Validate()
     : validation_.setTrackExtras(*this) 
       : if (sim seeds) extra.setMCTrackIDInfoByLabel() // Require 50% of found hits after seed to match label of seed/sim track
       : if (cms seeds) extra.setMCTrackIDInfo() // Require 75% of found hits to match a single sim track
     : validation_.makeSimTkToRecoTksMaps(*this)
       : mapRefTkToRecoTks(seedtracks,seedextras,simToSeedMap) // map key = mcTrackID, map value = vector of seed labels
       : mapRefTkToRecoTks(buildtracks,buildextras,simToBuildMap) // map key = mcTrackID, map value = vector of build labels
       : mapRefTkToRecoTks(fittracks,fitextras,simToFitMap) // map key = mcTrackID, map value = vector of fit labels
     : validation_.makeSeedTkToRecoTkMaps(*this)
       : mapSeedTkToRecoTk(buildtracks,buildextras,seedToBuildMap) // map key = seedID, map value = build track label
       : mapSeedTkToRecoTk(fittracks,fitextras,seedToFitMap) // map key = seedID, map value = fit track label
     : validation_.fillEfficiencyTree(*this)	
     : validation_.fillFakeRateTree(*this)	

[2.] builder.cmssw_val()
   : remap_cand_hits()
   : prep_recotracks()
     : prep_tracks(buildtracks,buildextras)
       : m_event->validation_.alignTracks(tracks,extras,false)
   : prep_cmsswtracks()
     : prep_tracks(cmsswtracks,cmsswextras)	
       : m_event->validation_.alignTracks(tracks,extras,false)	
   : m_event->Validate()
     : validation_.setTrackExtras(*this)
       : extra.setCMSSWTrackInfo() // Chi2 and dphi matching (also incudes option for nHits matching)
     : validation_.makeCMSSWTkToRecoTksMaps(*this)
       : mapRefTkToRecoTks(buildtracks,buildextras,cmsswToBuildMap)
     : validation_.fillCMSSWEfficiencyTree(*this)	
     : validation_.fillCMSSWFakeRateTree(*this)	

=======================================
 C. Explanation of validation routines
=======================================

- map/remap hit functions: see notes in section E. Essentially, validation needs all hit indices inside tracks to match the hit indices inside ev.layerHits_.

+++++++++++++++++++++++++++
 I. Tracks and Extras Prep
+++++++++++++++++++++++++++

- prep_tracks(tracks,extras) 
  : Loop over all tracks in consideration
    : sort hits inside track by layer : needed for counting unique layers and for association routines
    : emplace_back a track extra, initialized with the label of the track (which happens to be its seed ID)
  : m_event->validation_.alignTracks(tracks,extras,alignExtra)   

- alignTracks(tracks,extras,alignExtra)
  : if alignExtra == true // needed for when a reco track collection, which was previously labeled by its label() == seedID, created its track extra at the same time but the track collection has been moved or sorted
    : create temporary track extra collection, size of track collection
    : loop over tracks
      : set tmp extra to the old track extra collection matching the track label
    : set the old track extra to equal the new collection
  : loop over tracks
    : set the track label equal to the index inside the vector // needed for filling routines which rely on maps of indices between two track collections

- prep_cmsswtracks()
  : Stanard prep_tracks()
  : loop over cmssw tracks
    : Count unique layers = nLayers
    : set status of cmssw track to notFindable() if: (nLayers < [Config::cmsSelMinLayers == 8] || cmssw.pT() < [Config::cmsSelMinPt == 0.5]) // same criteria for "notFindable()" cmssw sim tracks used for seeds

++++++++++++++++++++++++++++++++
 II. Track Association Routines
++++++++++++++++++++++++++++++++

- setTrackExtras(&Event)    
  : if [1.]
    : loop over seed tracks
      : setMCTrackIDInfo(true) : Require 75% of found hits to match a single sim track
    : loop over build tracks
       : if (sim seeds) setMCTrackIDInfoByLabel() : Require 50% of found hits after seed to match label of seed/sim track
       : if (cms seeds) setMCTrackIDInfo(false) : Require 75% of found hits to match a single sim track
    : loop over fit tracks 
      : same options as build tracks   
  : if [2.]
    : first loop over cmssw tracks
      : create a vector of "reduced tracks" that stores 1./pt, eta, and associated covariances in reduced track states
      : also include track momentum phi, and a list of hits inside a map. map key = layer, map value = vector of hit indices
    : loop over build tracks
      : setCMSSWTrackIDInfo() : require matching by chi2 and dphi

- setMCTrackIDInfoByLabel(label)
  : if no hits are found after seed, mcTrackID == -4, and skip the rest of the function
  : Loop over found hits on build track after seed
    : count the hits who have a mcTrackID == label (i.e. seedID == simTrack label == mcTrackID)
  : if 50% are matched, mcTrackID == label
  : else, mcTrackID == -1
  : if (track.nFoundHits() < [Config::nMinFoundHits == 7] - [Config::nlayers_per_seed == 4 or 3]) 
    : if already matched, mcTrackID = -2
    : else, mcTrackID = -3
    
- setMCTrackIDInfo(isSeedTrack)
  : if track somehow has zero hits on track, mcTrackID = -5 --> should never happen unless some really deep bug
  : Loop over all found hits on build track (includes seed hits)
    : count the mcTrackID that appears most from the hits
  : if 75% of hits on reco track match a single sim track, mcTrackID == mcTrackID of single sim track
  : else, mcTrackID == -1
  : if (!isSeedTrack)
    : if (track.nFoundHits() < [Config::nMinFoundHits == 7])
      : if already matched, mcTrackID = -2
      : else, mcTrackID = -3
    : if already matched 
      : if simtrack matched to isNotFindable()
       	: if failed check on length of track (i.e. -2), mcTrackID == -7
	: else, mcTrackID == -6

- setCMSSWTrackIDInfo()
  : Loop over all cmssw "reduced" tracks
    : if helix chi2 < [Config::minCMSSWMatchChi2 == 50]
      : append label of cmssw track to a vector, along with chi2
  : sort vector by chi2
  : loop over label vector
    : swim cmssw track momentum phi from phi0 to mkFit reco track
    : if abs(wrapphi(dphi)) < [Config::minCMSSWMatchdPhi == 0.03]
      : see if dphi < currently best stored mindphi, and if yes, then set this as the new mindphi + label as matched cmsswTrackID
      : if using nHits matching, check for nHits matched --> currently not used nor tuned
  : if no label is found, cmsswTrackID == -1
  : follow same logic for labeling as setMCTrackIDInfo for -2, -3, -6, -7    

- mapRefTkToRecoTks(tracks,extras,map)
  : Loop over reco tracks
    : get track extra for track
    : if [1.], map[extra.mcTrackID()].push_back(track.label()) // reminder, label() now equals index inside track vector!
    : if [2.], map[extra.cmsswTrackID()].push_back(track.label()) // reminder, label() now equals index inside track vector!
  : Loop over pairs in map
    : if vector of labels size == 1, get track extra for label, and set duplicate index == 0
    : else
      : make temp track vector from track labels, sort track vector by nHits (and sum hit chi2 if tracks have same nHits)
      : set vector of labels to sorted tracks
      : loop over vector labels
      	: get track extra for label, and set duplicate index++ 

- mapSeedTkToRecoTk(tracks,extras,map)
  : loop over reco tracks
    : map[extra.seedID()] = track.label()

++++++++++++++++++++
 III. TTree Filling
++++++++++++++++++++

- fillEfficiencyTree()
  : loop over simtracks
    : get mcTrackID (i.e. simTrack.label())
    : store sim track gen info
    : if simToSeedMap[mcTrackID] has value
      : mcmask == 1
      : get first seed track matched (i.e. the one with the highest nHits --> or lowest sum hit chi2 as provided by sort from above)
      : store seed track parameters
      : store nHits, nlayers, last layer, chi2, duplicate info
      : get last found hit index
      	: store hit parameters
	: if mcTrackID of hit == mcTrackID of sim track // ONLY for when simtrackstates are stored, i.e. in ToyMC only at the moment
	  : store sim track state momentum info from this layer (from simTrackStates[mcHitID])
	: else get sim track state of mcTrackID, then store momentum info
    : else
      : mcmask == 0, or == -1 if simtrack.isNotFindable()
    : if simToBuildMap[mcTrackID] has value
      : repeat as above
    : if simToFitMap[mcTrackID] has value
      : repeat as above
    : fill efftree

- fillFakeRateTree()
  : loop over seed tracks
    : get seedID of seed track from track extra
    : fill seed track parameters + last hit info, nhits, etc
    : assign mcmask info based on mcTrackID from track extra (see section D and G for explanation of mask assignments)
    : if mcmask == 1
      : store gen sim momentum parameters
      : store nhits info, last layer, duplicate info
      : if last hit found has a valid mcHitID
      	: store sim track state momentum info from simTrackStates[mcHitID]
    : if seedToBuildMap[seedID] has value
      : fill build track parameters + last hit info, nhits, etc
      : assign mcmask info based on mcTrackID from track extra (see section D and G for explanation of mask assignments)
      : if mcmask == 1
      	: store gen sim momentum parameters
        : store nhits info, last layer, duplicate info
        : if last hit found has a valid mcHitID
      	  : store sim track state momentum info from simTrackStates[mcHitID]
    : if seedToFitMap[seedID] has value
      : same as aboe
    : fill frtree

- fillCMSSWEfficiencyTree()
  : loop over cmsswtracks
    : get label of cmsswtrack
    : store cmssw track PCA parameters + nhits, nlayers, last layer
    : if cmsswToBuilddMap[cmsswtrack.label()] has value
      : get first build track matched (i.e. the one with the highest nHits --> or lowest sum hit chi2 as provided by sort from above)
      : store build track parameters + errors
      : store nHits, nlayers, last layer, last hit parameters, hit and helix chi2, duplicate info
      : swim cmssw phi to mkFit track, store it
    : fill cmsswefftree

- fillCMSSWFakeRateTree()
  : loop over build tracks
    : store build track parameters + errors
    : store nHits, nlayers, last layer, last hit parameters, hit and helix chi2, duplicate info
    : get cmsswTrackID, assign cmsswmask according to section D and G
    : if cmsswmask == 1 
      : store cmssw track PCA parameters + nhits, nlayers, last layer
      : swim cmssw phi to mkFit track, store it
    : fill cmsswefftree

=============================================================
 D. Definitions of efficiency, fake rate, and duplicate rate
=============================================================

Use rootValidation.C to create efficiency, fake rate, and duplicate rate vs. pT, phi, eta. This macro compiles PlotValidation.cpp/.hh. Efficiency uses sim track momentum info. Fake rate uses the reco track momentum. For [1.], plots are made for seed, build, and fit tracks. For [2.], the plots are only against the build tracks. 

root -l -b -q runValidation.C\([agruments]\)

Argument list: 
First is additional input name of root file [def = ""]
Second argument is boolean to compute momentum pulls: currently implemented only when sim track states are available (ToyMC validation only)! [def = false]
Third argument is boolean to do special CMSSW validation [def = false]
Fourth argument == true to move input root file to output directory, false to keep input file where it is. [def = true]
Fifth argument is a bool to save the image files [def = false]
Last argument is output type of plots [def = "pdf"]

Efficiency [PlotValidation::PlotEfficiency()]
  numerator:   sim tracks with at least one reco track with mcTrackID >= 0 (mcmask_[reco] == 1)
  denominator: all findable sim tracks (mcmask_[reco] = 0 || == 1)
  mcmask_[reco] == - 1 excluded from both numerator and denominator because this sim track was not findable!

Fake Rate (with only long reco tracks: Config::inclusiveShorts == false) [PlotValidation::PlotFakeRate()]
  numerator:   reco tracks with mcTrackID == -1 
  denominator: reco tracks with mcTrackID >= 0 || == -1 || == -6
  mcTrackID | mcmask_[reco] 
     >= 0   |     1
      -1    |     0
      -6    |     2   
     else   |    -1

Fake Rate (with all reco tracks: Config::inclusiveShorts == true, enabled with command line option: --inc-shorts) [PlotValidation::PlotFakeRate()]
  numerator:   reco tracks with mcTrackID == -1 || == -3
  denominator: reco tracks with mcTrackID >= 0  || == -1 || == -2 || == -3 || == -4 || == -6 || == -7 
        mcTrackID       | mcmask_[reco] 
           >= 0         |     1
        -1 or -3        |     0
   -2 or -4 or -6 or -7 |     2   

Duplicate Rate [PlotValidation::PlotDuplicateRate()]
  numerator:   sim tracks with more than reco track match (nTkMatches_[reco] > 1)
  denominator: sim tracks with at least one reco track with mcTrackID >= 0 (mcmask_[reco] == 1)

========================
 E. Overview of scripts
========================

./validation-snb-toymc-fulldet-build.sh
Runs ToyMC full detector tracking for BH, STD, CE, for 400 events with nTracks/event = 2500. Sim seeds only.

./validation-snb-cmssw-fulldet-build.sh
Runs CMSSW full detector tracking for BH, STD, CE, for ~1000 events with 10 muons/event, with sim and cmssw seeds.
Samples are split by eta region. Building is run for each region:
- ECN2: 2.4 < eta < 1.7
- ECN1: 1.75 < eta < 0.55
- BRL: |eta| < 0.6
- ECP1: 0.55 < eta < 1.75
- ECP2: 1.7 < eta < 2.4

Validation plots are produced for each sample (region), seeding source, and building routine. At the very end, validation trees are hadd'ed for each region in a given seed source + building routine. Plots are produced again to yield "full-detector" tracking.

./validation-snb-cmssw-fulldet-extrectracks.sh
Same as above, but now only run with cmssw seeds (as we are comparing directly to cmssw output as the reference).

============================
 F. Hit map/remapping logic
============================

*** Originally from mkFit/MkBuilder.cc ***

All built candidate tracks have all hit indices pointing to m_event_of_hits.m_layers_of_hits[layer].m_hits (LOH)
MC seeds (both CMSSW and toyMC) have seed hit indices pointing to global HitVec m_event->layerHits_[layer] (GLH)
"Real" seeds have all seed hit indices pointing to LOH.
So.. to have universal seed fitting function --> have seed hits point to LOH no matter their origin.
This means that all MC seeds must be "mapped" from GLH to LOH: map_seed_hits().
Now InputTracksAndHits() for seed fit will use LOH instead of GLH.
The output tracks of the seed fitting are now stored in m_event->seedTracks_.

Then building proceeds as normal, using m_event->seedTracks_ as input no matter the choice of seeds. 

For the validation, we can reuse the TrackExtra setMCTrackIDInfo() with a few tricks.
Since setMCTrackIDInfo by necessity uses GLH, we then need ALL track collections (seed, candidate, fit) to their hits point back to GLH.
There are also two validation options: w/ or w/o ROOT.

W/ ROOT uses the TTreValidation class which needs seedTracks_, candidateTracks_, and fitTracks_ all stored in m_event.
The fitTracks_ collection for now is just a copy of candidateTracks_ (eventually may have cuts and things that affect which tracks to fit).
So... need to "remap" seedTracks_ hits from LOH to GLH with remap_seed_hits().
And also copy in tracks from EtaBin* to candidateTracks_, and then remap hits from LOH to GLH with quality_store_tracks() and remap_cand_hits().
W/ ROOT uses root_val_BH for BH, and root_val_COMB() for non-BH.

W/O ROOT is a bit simpler... as we only need to do the copy out tracks from EtaBin* and then remap just candidateTracks_.
This uses quality_output_COMB() or quality_output_BH()

N.B.1 Since fittestMPlex at the moment is not "end-to-end" with candidate tracks, we can still use the GLH version of InputTracksAndHits()
N.B.2 Since we inflate LOH by 2% more than GLH, hit indices in building only go to GLH, so all loops are sized to GLH.

==========================================
 G. Extra info on ID and mask assignments
==========================================

*** Originally from Track.cc ***

mcTrackID assignments 
ID >=  0 : reco track matched to sim track (n eligible found reco hits matching single sim track above some threshold, and n eligible found reco hits above some threshold) 
ID == -1 : reco track is a true fake (n eligible found reco hits matching single sim track below some threshold, and n eligible found reco hits above some threshold) 
ID == -2 : reco track is a matched short track --> inefficient but not fake (n eligible found reco hits matching single sim track above some threshold, and n eligible found reco hits below some threshold) 
ID == -3 : reco track is a short fake (n eligible found reco hits matching single sim track below some threshold, and n eligible found reco hits below some threshold) --> TOYMC SIM SEEDS ONLY
ID == -4 : reco track never made it past its sim seed --> inefficient but not fake --> TOYMC SIM SEEDS ONLY
ID == -5 : reco track somehow has zero hits... unclear what to do with these... ---> CMSSW OR REAL SEEDS ONLY
ID == -6 : reco track is long, and matched to sim track.  however, simtrack is unfindable (enter denom of FR)
ID == -7 : reco track is short, and matched to sim track. however, simtrack is unfindable (enter denom of FR for inclusive shorts)

N.B. CMSSW TrackID uses same assignments!

*** Originally from TTreeValidation.cc ***

mcTrackID assignments in Track.cc

_[reco] = {seed,build,fit}

N.B. Mask assignments
--> mcmask_[reco] == 1,"associated" reco to sim track [possible duplmask_[reco] == 1,0] {eff and FR}, enter numer and denom of eff, enter denom only of FR
--> mcmask_[reco] == 0,"unassociated" reco to sim track. by definition no duplicates (no reco to associate to sim tracks!) [possible duplmask_[reco] == 2 {eff and FR}], enter denom only of eff, enter numer and denom of FR
--> mcmask_[reco] == -1, sim or reco track excluded from denominator (and therefore numerator) [possible duplmask_[reco] == -1] {eff and FR}
--> mcmask_[reco] == 2, reco track included in demoninator of FR, but will not enter numerator: for short "matched" tracks of mcTrackID == -2,-4 {FR only}

--> nTkMatches_[reco] > 1,   n reco tracks associated to the same sim track ID {eff only}
--> nTkMatches_[reco] == 1,  1 reco track associated to single sim track ID {eff only}
--> nTkMatches_[reco] == -99, no reco to sim match {eff only}

excluding position variables, as position could be -99!
--> reco var == -99, "unassociated" reco to sim track [possible mcmask_[reco] == 0,-1,2; possible duplmask_[reco] == 2] {eff only}
--> sim  var == -99, "unassociated" reco to sim track [possible mcmask_[reco] == 0,-1,2; possible duplmask_[reco] == 2] {FR only}
--> reco/sim var == -100, "no matching seed to build/fit" track, fill all reco/sim variables -100 [possible mcmask_[reco] == -1, possible duplmask_[reco] == -1] {FR only}
--> sim  var == -101, reco track is "associated" to sim track, however, sim track does have a hit on the layer the reco track is on

--> seedmask_[reco] == 1, matching seed to reco/fit track [possible mcmask_[reco] == 0,1,2; possible duplmask_[reco] == 0,1,2] {FR only}
--> seedmask_[reco] == 0, no matching seed to reco/fit track [possible mcmask_[reco] == -1; possible duplmask_[reco] == -1] {FR only}

--> duplmask_[reco] == 0, only "associated" reco to sim track [possible mcmask_[reco] == 1] {eff and FR}
--> duplmask_[reco] == 1, more than one "associated" reco to sim track [possible mcmask_[reco] == 1] {eff and FR}
--> duplmask_[reco] == 2, no "associated" reco to sim track [possible mcmask_[reco] == 0,-1,2] {eff and FR}
--> duplmask_[reco] == -1, no matching built/fit track for given seed [possible mcmask_[reco] == -1] {FR only}

--> reco var == -10, variable not yet implemented for given track object

position reco variables
--> layers_[reco]    ==  -1, reco unassociated to sim tk {eff only}
--> reco pos+err var == -2000, reco tk is unassociated to sim tk {eff only}
--> reco pos+err var == -3000, reco tk is unassociated to seed tk {FR only}
